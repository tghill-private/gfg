# Jonathan Barenboim, December 2016
# This function generates a gif of a 2D cross section of the data generated by MITgcm
# This function is intended to create simple gifs with few options, quickly
# To use from the command line, follow the module name with the parameters IN THIS ORDER:
#	cut_var: the coordinate to produce the cross section at. Must be 'x', 'y', or 'z'
# 	cut_val: the value at which to produce the cross section at
# 	name_var: the prefix of the .data and .meta files. Example 'T' or 'rho'
# 	movie_name: the desired name of the generated movie
# This function can also be imported and called from a python script

from __future__ import division
import sys

import numpy
import subprocess as sp
import scipy.ndimage.interpolation as interp
from math import floor, ceil

import matplotlib
matplotlib.use('Agg')
import matplotlib.pyplot as pplot

from readmds import rdmds
import utils

# Includes start_time, end_time, sec_per_iter, sec_per_file,
#	nx, ny, nz, dx, dy, dz, initial_min, initial_max, inflow_min, inflow_max
try:
	from variables import *
except Exception as e:
	from readmataspy import *

def make_gif(cut_var, cut_val, name_var, movie_name):
	# get the center coordinates of the grid
	# TODO solve whitespace issue for plotting vertical coordinate
	grids = utils.MITgcm_getgrid ('C')

	# set the data and labels for the axes
	axes = ['x', 'y', 'z']
	grid_axes = axes[:]
	npoints = [nx, ny, nz]
	resolutions = [dx, dy, dz]
	cut_axis_index = axes.index(cut_var)
	grid_axes.remove(cut_var)
	x_axis_label = grid_axes[0] + "(m)"
	y_axis_label = grid_axes[1] + "(m)"
	axis_indeces = [axes.index(grid_axes[0]), axes.index(grid_axes[1])]
	x_axis_res = resolutions[axis_indeces[0]]
	y_axis_res = resolutions[axis_indeces[1]]
	x_axis_points = npoints[axis_indeces[0]]
	y_axis_points = npoints[axis_indeces[1]]
	grid_cut_val = int(utils.getgridcutval (cut_val, resolutions[cut_axis_index], npoints[cut_axis_index]))

	# initialize data array
	data = numpy.zeros( (len(x_axis_data), len(y_axis_data)) )

	iter_per_file = sec_per_file // sec_per_iter
	num_files = (end_time - start_time) // sec_per_file

	# Create the directories for the images and gifs
	pngdir = "PNG_IMAGES"
	gifdir = "GIF_MOVIES"
	sp.call(["mkdir", "-p", pngdir])
	sp.call(["mkdir", "-p", gifdir])

	# Zoom the data if there are not enough points to ensure smooth plotting
	zoom = (ceil(100 / x_axis_points), ceil(100 / y_axis_points))
	zoom _data = zoom != (1, 1)

	# Zoom the axis data
	if zoom_data:
		if zoom[0] != 1:
				x_axis_data = interp.zoom(x_axis_data, zoom[0], order=3)
		if zoom[1] != 1:
			y_axis_data = interp.zoom(y_axis_data, zoom[1], order=3)

	# Set the min and max temperature values for the colormap scale
	if name_var == 'T':
		try:
			vmax = max(initial_max, inflow_max)
			vmin = min(initial_min, inflow_min)
		except NameError:
			try:
				vmax = initial_max
				vmin = initial_min
			except NameError:
				vmin = None
				vmax = None

	# Set colormap to show land squares as brown
	cmap = matplotlib.cm.jet
	cmap.set_bad('#603a17', 1)

	# Set figure size
	if x_axis_points >= y_axis_points:
		figsize_x = 16
		figsize_y = round(figsize_x * y_axis_points / x_axis_points)
		figsize_y = max (6, min(figsize_y, 10))
	else:
		figsize_y = 10
		figsize_x = max(6, round(figsize_y * x_axis_points / y_axis_points))

	# Create a mask of land values
	land_area = numpy.transpose(utils.getland(cut_var, grid_cut_val, zoom, nx, ny, nz, dz))

	for m in range(num_files):
		# read the data into python
		D = rdmds (name_var, int(m * iter_per_file))
		if cut_var in ['x', 'X']:
			data = D[grid_cut_val,:, :]
		elif cut_var in ['y', 'Y']:
			data = D[:, grid_cut_val, :]
		else:
			data = D[:, : ,grid_cut_val]
		data = data.transpose()

		# Set the figure size
		pplot.figure(figsize=(figsize_x, figsize_y))

		# Create title and filename
		time_str = utils.convertseconds (m * sec_per_file, show_days)
		plot_title = "{0} at {1}={2}m at {3}".format(name_var, cut_var, cut_val, time_str)
		filename = "{0}/{1}.{2:04}.png".format(pngdir), movie_name, m)

		# Zoom the data
		if zoom_data:
			# Necessary since ndarrays are printed with y axis first
			zoom2 = (zoom[1], zoom[0])
			data = interp.zoom(data, zoom2, order=3)

		# Mask the data
		masked = numpy.ma.array (data, mask=land_area)

		# Plot the image
		pplot.pcolormesh(x_axis_data, y_axis_data, masked, vmin=vmin, vmax=vmax, cmap=cmap)

		# ensure origin is in lower left corner
		pplot.ylim(min(pplot.ylim()), max(pplot.ylim()))

		# add titles and axis labels
		pplot.title(plot_title)
		pplot.xlabel(x_axis_label)
		pplot.ylabel(y_axis_label)

		pplot.colorbar()
		pplot.savefig(filename)
		pplot.close()

		if (m + 1) % 10 == 0:
			print ("{0} of {1} images generated".format(m + 1, num_files))

		# Stich together the gif and optimize the file
		print ("Stitching together the gif...")
		gif_filename = "{0}/{1}.gif".format(gifdir, movie_name)
		img_files = "{0}/{1}.*.png".format(pngdir, movie_name)
		sp.call(["convert", "-delay", "14", "-depth", "8", "-loop", "1", img_files, gif_filename])
		# TODO: fix this call
		#sp.call(["gifscile", "-b", "-O1", "--colors", "256", "--careful", gif_filename])

cut_var = sys.argv[1]
cut_val = sys.argv[2]
name_var = sys.argv[3]
movie_name = sys.argv[4]

make_gif(cut_var, cut_val, name_var, movie_name)
