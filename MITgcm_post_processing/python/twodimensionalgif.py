# Jonathan Barenboim, October 2016
# This function generates a gif of a 2D cross section of the data generated by MITgcm
# INPUT:
# gif_args: A dictionary that contains the following arguments:
#	cut_var: The coordinate to produce the cross section at. Must be 'x', 'y', or 'z'
# 	cut_val: The value at which to produce the cross section, in meters
# 	data_var: The prefix of the .data and .meta files. Example 'T' or 'rho'
# 	movie_name: The desired name of the generate gif
#	vmin, vmax: The minimum and maximum for the colorbar scale
#	file_type: The file type to save the images as
#	iter_start, iter_range: Range of iterations to plot
#				If None, entire runtime is plotted
#	stitch_gif: whether or not to stitch the images into a gif
#	x_axis_start, x_axis_end, y_axis_start, y_axis_end: range of data to be plotted
#				If None, start or end of data is used
# 	image_folder_name, gif_folder_name: name of the folders to save images and gifs in
#   bathy_file_name: name of the bathymetry binary file

from __future__ import division

import numpy
import subprocess as sp
import scipy.ndimage.interpolation as interp
from math import floor, ceil

import matplotlib
matplotlib.use('Agg')
import matplotlib.pyplot as pplot
from mpl_toolkits.axes_grid1 import make_axes_locatable

from readmds import rdmds
import utils
import setupgif

# Includes start_time, end_time, sec_per_iter, sec_per_file,
#	nx, ny, nz, dx, dy, dz, initial_min, initial_max, inflow_min, inflow_max
try:
	from variables import *
except Exception as e:
	from readmataspy import *


def twodimensionalgif (gif_args):
	# Check input is valid and set default parameters
	setupgif.check_requireds(gif_args)
	gif_args = setupgif.set_default(gif_args)
	setupgif.check_types(gif_args)
	setupgif.check_optionals(gif_args)
	setupgif.print_params(gif_args)
	setupgif.check_extraneous(gif_args)
	print ("----------")

	# Option to format time into days. See utils.py for more info
	show_days = True if end_time >= 86400 else False

        
	# Set iter_start and iter_end to default values if None

	iter_per_file = float(sec_per_file // sec_per_iter)
	print ("iter_per_file = {0}".format(iter_per_file))

	iter_per_file = int(sec_per_file // sec_per_iter)
	print ("sec_per_file = {0}".format(sec_per_file))
	print ("sec_per_iter = {0}".format(sec_per_iter))
	print ("iter_per_file = {0}".format(iter_per_file))

	if gif_args['iter_start'] == None:
		gif_args['iter_start'] = 0
	
	if gif_args['iter_end'] == None:
		gif_args['iter_end'] = int((end_time - start_time) // sec_per_iter)

	# Set range of files to go through. iter_range = range(2,4) means files 2 and 3 are plotted. If iter_per_file = 2 then T.4.data and T.6.data are plotted
	if gif_args['data_var'].lower() == 'rho':
		iter_range = range(gif_args['iter_start'], gif_args['iter_end'], iter_per_file)
	else:
		iter_range = range(gif_args['iter_start'], gif_args['iter_end'] + 1, iter_per_file)

	num_files = len(iter_range)
	print ("number of files:   {0}".format(num_files))

	# get the center coordinates of the grid
	# TODO solve whitespace issue for plotting vertical coordinate
	grids = utils.MITgcm_getgrid ('C')

	# set the data and labels for the axes
	axes = ['x', 'y', 'z']
	grid_axes = axes[:]
	npoints = [nx, ny, nz]
	resolutions = [dx, dy, dz]
	cut_axis_index = axes.index(gif_args['cut_var'])
	grid_axes.remove(gif_args['cut_var'])
	x_axis_label = grid_axes[0] + "(m)"
	y_axis_label = grid_axes[1] + "(m)"
	axis_indeces = [axes.index(grid_axes[0]), axes.index(grid_axes[1])]
	x_axis_res = resolutions[axis_indeces[0]]
	y_axis_res = resolutions[axis_indeces[1]]
	x_axis_points = npoints[axis_indeces[0]]
	y_axis_points = npoints[axis_indeces[1]]
	grid_cut_val = int(utils.getgridcutval (gif_args['cut_val'], resolutions[cut_axis_index], npoints[cut_axis_index]))
	print ("grid_cut_val = {0}".format(grid_cut_val))

	# Get indeces of starting and ending axis values
	xis = utils.getgridcutval(gif_args['x_axis_start'], x_axis_res, x_axis_points)
	xie = utils.getgridcutval(gif_args['x_axis_end'], x_axis_res, x_axis_points)
	yis = utils.getgridcutval(gif_args['y_axis_start'], y_axis_res, y_axis_points)
	yie = utils.getgridcutval(gif_args['y_axis_end'], y_axis_res, y_axis_points)
	if xie is not None:
		xie += 1
	if yie is not None:
		yie += 1

	# Set axis data according to plotting ranges
	# Note a[None:3] is equivalent to a[:3]
	x_axis_data = grids[axis_indeces[0]][xis:xie ]
	y_axis_data = grids[axis_indeces[1]][yis:yie ]	
	print ("x_axis_start index: {0}".format(xis))
	print ("x_axis_end index: {0}".format(xie))
	print ("y_axis_start index: {0}".format(yis))
	print ("y_axis_end index: {0}".format(yie))

	#get origin for imshow plots
	if gif_args['cut_var'] == 'z':
		origin_val = 'lower'
	else:
		origin_val = 'upper'
                

	# initialize data array
	data = numpy.zeros( (len(x_axis_data), len(y_axis_data)) )

	temp1 = len(x_axis_data)
	temp2 = len(y_axis_data)
	print ("Lx: {0}".format(temp1))
	print ("Ly: {0}".format(temp2))

	# Create the directories for the images and gifs
	sp.call(["mkdir", "-p", gif_args['image_folder_name']])
	sp.call(["mkdir", "-p", gif_args['gif_folder_name']])

	# zoom the data if there are not enough points to ensure smooth plotting
	tmp_zoom_x = ceil(gif_args['min_points'] / len(x_axis_data))	
	tmp_zoom_y = ceil(gif_args['min_points'] / len(y_axis_data))
	zoom = (tmp_zoom_x, tmp_zoom_y)
	zoom_data = zoom != (1, 1)
	print ("zoom factors:     " + str(zoom))

	# Zoom the axis data
	if zoom_data:
		if zoom[0] != 1:
				x_axis_data = interp.zoom(x_axis_data, zoom[0], order=3)
		if zoom[1] != 1:
			y_axis_data = interp.zoom(y_axis_data, zoom[1], order=3)

	# Set the min and max temperature values for the colormap scale
	if gif_args['data_var'] == 'T' and gif_args['vmin'] is None:
		try:
			gif_args['vmax'] = max(initial_max, inflow_max)
			gif_args['vmin'] = min(initial_min, inflow_min)
		except NameError:
			try:
				gif_args['vmax'] = initial_max
				gif_args['vmin'] = initial_min
			except NameError:
				pass

	# Track minimum and maximum values being plotted
	min_data = None
	max_data = None

	# Set colormap to show land squares as brown
	cmap = matplotlib.cm.jet
	cmap.set_bad('#603a17', 1)

	pplot.hold(False) 
	
	# Set figure size
	if x_axis_points >= y_axis_points:
		ratio = y_axis_points/x_axis_points
		figsize_x = 6
		figsize_y = round(figsize_x*ratio)
#		figsize_y = max(3,figsize_y)
		figsize_y = max(2,figsize_y)
	else:
		ratio = x_axis_points/y_axis_points
		figsize_y = 6
		figsize_x = round(figsize_y*ratio)
		figsize_x = max(3,figsize_x)
	
	# Create a mask of land values
	land_area = utils.getland(gif_args['cut_var'], grid_cut_val, nx, ny, nz, dz, gif_args['bathy_file_name'])
	# Take the land area slice associated with the plotting range
	land_area = utils.zoommask(land_area, xis, xie, yis, yie, zoom)
	# Transpose land_area so it's orientation matches data
	land_area = numpy.transpose(land_area)

	print ("----------")
	num_made = 0
	# Generate an image for each iteration
	for m in iter_range:
		num_made += 1
		# read the data into python
		D = rdmds (gif_args['data_var'], m)
		if gif_args['cut_var'] in ['x', 'X']:
			data = D[grid_cut_val, xis:xie, yis:yie]
		elif gif_args['cut_var'] in ['y', 'Y']:
			data = D[xis:xie, grid_cut_val, yis:yie]
		else:
			data = D[xis:xie, yis:yie ,grid_cut_val]

		# In pyplot, the data array C is printed in (rows, cols) order, whereas the 
		# axes X and Y represent columns and rows respectively
		# Therefore the data matrix must be transposed to match pyplot's requirements
		data = data.transpose()

		# Create title and filename
		time_str = utils.convertseconds (m * sec_per_iter, show_days)
		plot_title = "{0} at {1}={2}m at {3}".format(gif_args['data_var'], gif_args['cut_var'], gif_args['cut_val'], time_str)
		filename = "{0}/{1}.{2:010}.{3}".format(gif_args['image_folder_name'], gif_args['movie_name'], m, gif_args['file_type'])
		
		# Zoom the data
		if zoom_data:
			# Necessary since ndarrays are printed with y axis first
			zoom2 = (zoom[1], zoom[0])
			data = interp.zoom(data, zoom2, order=3)

		# Mask the data
		masked = numpy.ma.array (data, mask=land_area)

		# Plot the image

		pplot.figure(figsize=(figsize_x,figsize_y))

		if plot_type == None:
			pplot.pcolormesh(x_xais_data,y_axis_data,masked,vmin=gif_args['vmin'],vmax=gif_args['vmax'],cmap=cmap)
			# ensure origin is in lower left corner
			pplot.ylim(min(pplot.ylim()), max(pplot.ylim()))
			# add titles and axis labels
			pplot.title(plot_title)
			pplot.xlabel(x_axis_label)
			pplot.ylabel(y_axis_label)

			pplot.colorbar()
			pplot.savefig(filename, format=gif_args['file_type'],bbox_inches="tight")
			pplot.close()
		elif plot_type == 'gs':
			pplot.pcolormesh(x_xais_data,y_axis_data,masked,vmin=gif_args['vmin'],vmax=gif_args['vmax'],cmap=cmap,shading='gouraud')
			# ensure origin is in lower left corner
			pplot.ylim(min(pplot.ylim()), max(pplot.ylim()))
			# add titles and axis labels
			pplot.title(plot_title)
			pplot.xlabel(x_axis_label)
			pplot.ylabel(y_axis_label)

			pplot.colorbar()
			pplot.savefig(filename, format=gif_args['file_type'],bbox_inches="tight")
			pplot.close()
		elif plot_type == 'interp':
			#get axis
			ax = pplot.gca()
			#get axis max and min
			x_axis_min = numpy.min(x_axis_data)
			y_axis_min = numpy.min(y_axis_data)
			x_axis_max = numpy.max(x_axis_data)
			y_axis_max = numpy.max(y_axis_data)
			#plot data
			im = ax.imshow(masked,cmap=cmap,interpolation=interp_type,extent=[x_axis_min,x_axis_max,y_axis_min,y_axis_max],aspect='auto',origin=origin_val,vmin=gif_args['vmin'],vmax=gif_args['vmax'])
			# add titles and axis labels
			pplot.title(plot_title)
			pplot.xlabel(x_axis_label)
			pplot.ylabel(y_axis_label)
			#fix colorbar to same size as plot
			divider = make_axes_locatable(ax)
			cax = divider.append_axes("right",size="5%",pad=0.05)
			pplot.colorbar(im,cax=cax)
			pplot.savefig(filename, format=gif_args['file_type'],bbox_inches="tight")
			pplot.close()
			
		elif plot_type == 'contour':
			pplot.contourf(x_axis_data,y_axis_data,masked,contour_max,cmap=cmap,vmin=gif_args['vmin'],vmax=gif_args['vmax'])
			# add titles and axis labels
			pplot.title(plot_title)
			pplot.xlabel(x_axis_label)
			pplot.ylabel(y_axis_label)
			pplot.colorbar()
			pplot.savefig(filename, format=gif_args['file_type'],bbox_inches="tight")
			pplot.close()

		# Track the minimum and mavimum values
		temp_min = masked.min()
		temp_max = masked.max()
		if min_data == None or temp_min < min_data:
			min_data = temp_min

		if max_data == None or temp_max > max_data:
			max_data = temp_max

		if num_made % 10 == 0:
			print ("{0} of {1} images generated".format(num_made, num_files))

	print("Minimum data value: {0}".format(min_data))
	print("Maximum data value: {0}".format(max_data))

	if gif_args['stitch_gif']:
		# Stich together the gif and optimize the file
		print ("Stitching together the gif...")
		gif_filename = "{0}/{1}.gif".format(gif_args['gif_folder_name'], gif_args['movie_name'])
		img_files = "{0}/{1}.*.{2}".format(gif_args['image_folder_name'], gif_args['movie_name'], gif_args['file_type'])
#		sp.call(["convert", "-delay", "14", "-depth", "8", "-loop", "1", img_files, gif_filename])
		sp.call(["convert", "-delay", "4", "-depth", "8", "-loop", "1", img_files, gif_filename])
		# TODO: fix this call
		#sp.call(["gifscile", "-b", "-O1", "--colors", "256", "--careful", gif_filename])

